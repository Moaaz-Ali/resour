#!/usr/bin/perl

###############################################################################
###############################################################################
##
##  Copyright (C) Sistina Software, Inc.  1997-2001  All rights reserved.
##  Copyright (C) 2005 Red Hat, Inc.  All rights reserved.
##
##  This copyrighted material is made available to anyone wishing to use,
##  modify, copy, or redistribute it subject to the terms and conditions
##  of the GNU General Public License v.2.
##
###############################################################################
###############################################################################


die "build_debug <basename> <filenames>\n" unless (@ARGV > 1);


$base = $BASE = shift(@ARGV);

$base =~ tr/A-Z/a-z/;
$BASE =~ tr/a-z/A-Z/;



#  Collect the function list and remember which files they came from

foreach $file (@ARGV)
{
    open(DATAFILE, "< $file") || die;

    while ($line = <DATAFILE>)
    {
	if ($line =~ /^\s*ENTER\((\S+)\)/ ||
	    $line =~ /^\s*DO_PROF\((\S+),/ ||
	    $line =~ /^\s*DBFLAG\((\S+)\)/)
	{
	    $func = $1;

	    $funcs{$file} .= "$func ";
	    push(@funcall, $func);

	    $nfunc++;
	}
    }

    close(DATAFILE);
}



#  Build up the magic version number thingy

$version += &hash(sort @ARGV);

foreach $file (sort keys(%funcs))
{
    $version += &hash($file);
    $version += &hash(sort split(' ', $funcs{$file}));
}



#  Print out the header, version number, and flag counts

print "#ifndef __" . $BASE . "_DEBUG_DOT_H__\n";
print "#define __" . $BASE . "_DEBUG_DOT_H__\n\n\n\n";

print "#define " . $BASE . "_DEBUG_VERSION (\"$version\")\n";
print "#define " . $BASE . "_DEBUG_FLAGS ($nfunc)\n";
print "#define " . $BASE . "_DEBUG_FLAG_BYTES (", sprintf("%u", int(($nfunc + 7) / 8)), ")\n";
print "\n\n\n";



#  Print out the #defines for the symbols

foreach $file (sort keys(%funcs))
{
    print "/*  $file  */\n\n";

    @func_list = split(' ', $funcs{$file});

    foreach $func (sort @func_list)
    {
	printf("#define %-30s (%u)\n", $func, $count++);
    }

    print "\n\n";
}

print "\n\n\n";



#  Print out kernel stuff

print "#ifndef HELPER_PROGRAM\n\n\n";

print "#ifdef WANT_DEBUG_NAMES\n";
print "const char *", $base, "_debug_flag_names[] =\n";
print "{\n";
foreach $file (sort keys(%funcs))
{
    @func_list = split(' ', $funcs{$file});

    foreach $func (sort @func_list)
    {
	$lc_func = $func;
	$lc_func =~ tr/A-Z/a-z/;

	printf("  \"%s\",\n", $lc_func);
    }
}
print "  \"\"\n";
print "};\n";
print "#else  /*  WANT_DEBUG_NAMES  */\n";
print "extern const char *", $base, "_debug_flag_names[];\n";
print "#endif  /*  WANT_DEBUG_NAMES  */\n\n";



print "\n#else  /*  HELPER_PROGRAM  */\n\n\n";



#  Print out the debug_flag_t structure

print "#ifndef DEBUG_FLAG_DEFINITION\n";
print "#define DEBUG_FLAG_DEFINITION\n";
print "struct debug_flag\n";
print "{\n";
print "  const char             *name;\n";
print "  const unsigned int     len;\n";
print "  const unsigned int     *flag;\n";
print "};\n";
print "typedef struct debug_flag debug_flag_t;\n";
print "#endif  /*  DEBUG_FLAG_DEFINITION  */\n";
print "\n\n";



#  Print out the arrays for the individual functions

$x = 0;

foreach $file (sort keys(%funcs))
{
    @func_list = split(' ', $funcs{$file});

    foreach $func (sort @func_list)
    {
	printf("const unsigned int %s_DEBUGFUNC%u[] = {$func};\n", $BASE, $x++);
    }
}

print "\n\n";



#  Print out the arrays for whole files

$x = 0;

foreach $file (sort keys(%funcs))
{
    @func_list = split(' ', $funcs{$file});
    $func = join(', ', sort @func_list);

    printf("const unsigned int %s_DEBUGFILE%u[] = {$func};\n", $BASE, $x++);
}

print "\n\n";



#  Print out the "all" array

$funcall .= join(', ', sort @funcall);
printf("const unsigned int %s_DEBUGFUNCALL[] = {$funcall};\n", $BASE);
print "\n\n";



#  Print out the start of the the debug_flags structure

printf("const debug_flag_t %s_debug_flags[] =\n", $base);
print "{\n";



#  Print out the switches for the individual functions

$x = 0;

foreach $file (sort keys(%funcs))
{
    @func_list = split(' ', $funcs{$file});

    foreach $func (sort @func_list)
    {
	$lc_func = $func;
	$lc_func =~ tr/A-Z/a-z/;

	printf("  {\"%s\", %u, %s_DEBUGFUNC%u},\n", $lc_func, 1, $BASE, $x++);
    }
}



#  Print out the switches for whole files

$x = 0;

foreach $file (sort keys(%funcs))
{
    @func_list = split(' ', $funcs{$file});

    printf("  {\"%s\", %u, %s_DEBUGFILE%u},\n", $file, scalar(@func_list), $BASE, $x++);
}



#  Print out the "all" array

printf("  {\"all\", %u, %s_DEBUGFUNCALL},\n", $nfunc, $BASE);




#  Print out the structure footer


print '  {"", 0, NULL}', "\n";
print "};\n";
print "\n\n#endif  /*  HELPER_PROGRAM  */\n\n\n\n";



#  Print out the end of the header #ifdef

print "#endif  /*  __" . $BASE . "_DEBUG_DOT_H__  */\n\n";





#  There must be something (standard) that's better than this.

sub hash
{
    my(@strs) = @_;
    my($str, @letters, $letter);
    my($hash);

    foreach $str (@strs)
    {
	@letters = split('', $str);
	foreach $letter (@letters)
	{
	    $hash += unpack('C', $letter) << $hash_shift;
	    $hash_shift = ($hash_shift == 24) ? 0 : $hash_shift + 1;
	}
    }

    return $hash;
}

