#!/bin/bash
#
# chkconfig: 345 21 79
# description: Starts and stops cman
#
#
### BEGIN INIT INFO
# Provides:
### END INIT INFO
. /etc/init.d/functions
CCSD_OPTS=-X
# CMAN_CLUSTER_TIMEOUT -- amount of time to wait for joinging a cluster
#     before giving up.  If CMAN_CLUSTER_TIMEOUT is positive, then we will
#     wait CMAN_CLUSTER_TIMEOUT seconds before giving up and failing when
#     a cluster is not joined.  If CMAN_CLUSTER_TIMEOUT is zero, then
#     wait indefinately for a cluster join.  If CMAN_CLUSTER_TIMEOUT is
#     negative, do not check to see that the cluster has been joined
CMAN_CLUSTER_TIMEOUT=120

# CMAN_QUORUM_TIMEOUT -- amount of time to wait for a quorate cluster on 
#     startup quorum is needed by many other applications, so we may as 
#     well wait here.  If CMAN_QUORUM_TIMEOUT is less than 1, quorum will 
#     be ignored.
#CMAN_QUORUM_TIMEOUT=300
CMAN_QUORUM_TIMEOUT=0

# CMAN_SHUTDOWN_TIMEOUT -- amount of time to wait for cman to become a 
#     cluster member before calling cman_tool leave during shutdown.  
#     default is 60 seconds
CMAN_SHUTDOWN_TIMEOUT=60

# FENCED_START_TIMEOUT -- amount of time to wait for starting fenced
#     before giving up.  If FENCED_START_TIMEOUT is positive, then we will
#     wait FENCED_START_TIMEOUT seconds before giving up and failing when
#     fenced does not start.  If FENCED_START_TIMEOUT is zero, then
#     wait indefinately for fenced to start.
FENCED_START_TIMEOUT=120

LOCK_FILE="/var/lock/subsys/cman"

[ -n "$CLUSTERNAME" ] && cman_join_opts="-c $CLUSTERNAME"

load_modules()
{
    errmsg=$( /sbin/modprobe configfs 2>&1 ) || return 1
    errmsg=$( /sbin/modprobe dlm 2>&1 ) || return 1
    errmsg=$( /sbin/modprobe dlm_device 2>&1 ) || return 1
    return 0
}

start_configfs()
{
    # configfs
    awk '{ print $2 }' /etc/mtab | grep "/sys/kernel/config" &> /dev/null \
    && awk '{ print $3 }' /etc/mtab | grep "configfs" &> /dev/null
    if [ $? -ne 0 ]
    then
	errmsg=$( /bin/mount -t configfs none /sys/kernel/config 2>&1 )
	return $?
    fi
    return 0
}

start_ccsd()
{
    # ccsd
    status ccsd &> /dev/null
    if [ $? -ne 0 ]
    then
	errmsg=$(/sbin/ccsd $CCSD_OPTS 2>&1)
	return $?
    fi
    return 0
}

start_cman()
{
    # cman
    /sbin/cman_tool status &> /dev/null
    if [ $? -ne 0 ]
    then
	errmsg=$( /sbin/cman_tool -t $CMAN_CLUSTER_TIMEOUT -w join \
	    $cman_join_opts 2>&1 ) || return 1

	if [ $CMAN_QUORUM_TIMEOUT -gt 0 ]
	then
	    errmsg=$( /sbin/cman_tool -t $CMAN_QUORUM_TIMEOUT \
		    -q wait 2>&1 ) || return 1
	fi
    fi
    return 0
}

start_daemons()
{
    status groupd &> /dev/null
    if [ $? -ne 0 ]; then
	errmsg=$( /sbin/groupd 2>&1 ) || return 1
    fi
    status fenced &> /dev/null
    if [ $? -ne 0 ]; then
	errmsg=$( /sbin/fenced 2>&1 ) || return 1
    fi
    status dlm_controld &> /dev/null
    if [ $? -ne 0 ]; then
	errmsg=$( /sbin/dlm_controld 2>&1 ) || return 1
    fi
    status gfs_controld &> /dev/null
    if [ $? -ne 0 ]; then
	errmsg=$( /sbin/gfs_controld 2>&1 ) || return 1
    fi
    return 0
}

start_fence()
{
    errmsg=$( /sbin/fence_tool -j $FENCED_START_TIMEOUT join \
	     > /dev/null 2>&1 ) || return 1
    return 0
}

start()
{
    echo -n "Starting cluster: "
    load_modules
    [ $? -ne 0 ] && return 1
    start_configfs
    [ $? -ne 0 ] && return 1
    start_ccsd
    [ $? -ne 0 ] && return 1
    start_cman
    [ $? -ne 0 ] && return 1
    start_daemons
    [ $? -ne 0 ] && return 1
    start_fence
    [ $? -ne 0 ] && return 1
    
    return 0
}

stop_configfs()
{
    awk '{ print $2 }' /etc/mtab | grep "/sys/kernel/config" &> /dev/null\
    && awk '{ print $3 }' /etc/mtab | grep "configfs" &> /dev/null
    if [ $? -eq 0 ]
    then
	errmsg=$( /bin/umount /sys/kernel/config 2>&1 )
	return $?
    fi
    return 0
}

stop_ccsd()
{
    for sec in $(seq 1 10)
    do
	if /sbin/pidof ccsd &> /dev/null
	then
	    # get the pid of ccsd from /var/run/cluster/ccsd.pid
	    # and break if the file is not there
	    [ -r /var/run/cluster/ccsd.pid ] || break

	    pid=$(cat /var/run/cluster/ccsd.pid)
	    /usr/bin/kill $pid &> /dev/null || break
	    
	    sleep 1
	else
	    return 0
	fi
    done
    return 1
}

stop_cman()
{
    /sbin/cman_tool status &> /dev/null
    if [ $? -eq 0 ]
    then
    errmsg=$( /sbin/cman_tool -t $CMAN_SHUTDOWN_TIMEOUT \
	    -w leave $1 2>&1 ) || return 1
    fi
    return 0 # all ok
}

stop_daemons()
{
    if pid=$(/sbin/pidof gfs_controld 2>&1); then
	errmsg=$(/usr/bin/kill -9 $pid 2>&1) || return 1
    fi
    if pid=$(/sbin/pidof dlm_controld 2>&1); then
	errmsg=$(/usr/bin/kill -9 $pid 2>&1) || return 1
    fi
    if pid=$(/sbin/pidof fenced 2>&1); then
	errmsg=$(/usr/bin/kill -9 $pid 2>&1) || return 1
    fi
    if pid=$(/sbin/pidof groupd 2>&1); then
	errmsg=$(/usr/bin/kill -9 $pid 2>&1) || return 1
    fi
    return 0 # all ok
}

stop_fence()
{
    if /sbin/pidof fenced &> /dev/null
    then
	/sbin/fence_tool leave > /dev/null 2>&1
	return $?
    fi
    return 0 # all ok
}

stop()
{
    echo -n "Stopping cluster: "
    stop_fence
    [ $? -ne 0 ] && return 1
    stop_daemons
    [ $? -ne 0 ] && return 1
    if [ $1 ]; then
	stop_cman $1
    else
	stop_cman
    fi
    [ $? -ne 0 ] && return 1
    stop_ccsd
    [ $? -ne 0 ] && return 1
    stop_configfs
    [ $? -ne 0 ] && return 1
    return 0
}

rtrn=1

# See how we were called.
case "$1" in
    start)
	start
	rtrn=$?
	[ $rtrn = 0 ] && touch $LOCK_FILE
	if [ $rtrn -ne 0 ] 
	then
	    echo $errmsg
	    failure "failed to start cman"
	    echo
	else
	    success "start"
	    echo
	fi
	;;
    stop)
	if [ $2 ]; then
	    stop
	else
	    stop remove
	fi
	rtrn=$?
	[ $rtrn = 0 ] && rm -f $LOCK_FILE
	if [ $rtrn -ne 0 ] 
	then
	    echo $errmsg
	    failure "failed to stop cman"
	    echo
	else
	    success "shutdown"
	    echo
	fi
	;;

    restart)
	$0 stop restart
	$0 start
	rtrn=$?
	;;

    status)
	/sbin/cman_tool status 2>/dev/null
	rtrn=$?
	;;

    *)
	    echo $"Usage: $0 {start|stop|restart|status}"
	    ;;
esac

exit $rtrn
